#+TITLE: [WIP] Spaced k-mer seeded distance
#+HUGO_BASE_DIR: ..
#+HUGO_SECTION: papers
#+date: <2021-10-20 Wed>

*NOTE:* This is work in progress and covers [[/posts/spaced-kmer-distance][this post]].

\[
\newcommand{\vp}{\varphi}
\newcommand{\A}{\mathcal A}
\newcommand{\O}{\mathcal O}
\newcommand{\N}{\mathbb N}
\newcommand{\ed}{\mathrm{ed}}
\newcommand{\mh}{\mathrm{mh}}
\newcommand{\hash}{\mathrm{hash}}
\]


* Abstract
- new algorithm (3 sentence summary)
- results
- compare with other methods

* Introduction
- Introduce problem of evolutionary distance estimates
- Other methods for approximating/estimating evolutionary distance.
- Other methods for phylogeny reconstruction

** Terminology
**** k-mer
A (sub)string of $k$ consecutive characters.

**** Spaced seed
A /pattern/ of length $l$ and weight $w$: given a substring of
length $l$, the $w$ positions indicate the subset of positions we consider.
A pattern can be given as a binary string containing $w$
ones, or as a subset of size $w$ of $\{1, \dots, l\}$.

In the literature, a spaced seed usually includes the first and last character (those at
positions $1$ and $l$). We do not assume this.

**** Spaced k-mer
The $w$ characters induced by a spaced seed of weight $w$.

**** Matching positions
We say that two positions /match/ (assuming a spaced seed) if the spaced k-mers
induced by the spaced seed starting at these positions are the same.

**** Window
The $l$ characters surrounding a spaced k-mer, corresponding to the
chosen spaced seed. The window may extend outside the range of the leftmost and
right most character in the spaced k-mer.

- TODO: Maybe we actually should include both ends, as that should reduce
  vulnerability to accidentally having undetected indels at the ends, which
  is bad for measuring the hamming distance.
*** Example
The string ~ACTGC~ contains:
- the $4$-mers ~ACTG~ and ~CTGC~;
- for the spaced seed ~1101~, the spaced k-mers ~ACG~ and ~CTC~.
- the window ~ACTG~ and ~CTGC~. These are the same as the $4$-mers, but we will
  use this term explicitly for the characters surrounding a spaced k-mer.


** Algorithm overview
- Describe the algorithm in a few lines or bullet points.

Given two sequences $A$ and $B$, our method approximates the average hamming
distance between matching regions.
First we pick a random spaced seed of length $l$ and weight $w$,
where typical parameters are $l=128$ and $w=20$.
Then, we find all pairs of windows in $A$ and $B$ where this spaced seed
induces spaced k-mer matches.
Our estimate is the average hamming distance between matching windows.

To speed this up and reduce memory usage, we choose a filter size $f$ (around
$3$), and only take into account those positions where the first $f$ characters
of the spaced k-mer are exactly equal to some randomly chosen filter.

Averaging over multiple (typically around $20$) spaced k-mers and filter prefixes improves the accuracy.


* Spaced $k$-mer seeded distance
- Define spaced kmers, metric, ...
- Full explanation, with annoying details
- Pseudocode
- Example spaced kmers


#+BEGIN_SRC python
r = 20    # The number spaced seed and filter pairs to average over.
l = 128   # The length of the spaced seeds.
w = 20    # The weight of the spaced seeds.
f = 3     # The size of the filter

# Input: a pair of sequences.
# Output: a list of pairs of matching positions.
def get_matching_positions(A, B):
    # A list of pairs of matching pairs of positions.
    matching_positions = []

    for _ in range(r): # Repeat r times.
        # Pick a random spaced seed of length l and weight w.
        # Note that the code uses 0-based indices while the analysis is 1-based.
        W = random.sample(range(l), k=w)

        # Pick a random filter.
        F = random.choose('ACTG', k=f)

        # Hash all windows to their spaced kmers.
        # Hash table mapping spaced kmers the windows where they occur.
        spaced_kmer_occurences = defaultdict(list)
        # Loop over the two sequences
        for s in [A, B]:
            # Loop over start positions
            for j in range(len(s) - l + 1):
                window = s[j : j+l]
                spaced_kmer = [window[Li] for Li in L]
                # Does the spaced kmer pass the filter?
                if spaced_kmer[0:f] == F:
                    # A window is identified by its sequence and start position..
                    spaced_kmer_occurences[spaced_kmer].append((s, j))

        # All pairs of windows that hash to the same bucket are candidate matches.
        for spaced_kmer in spaced_kmers:
            # Loop over all unordered pairs of windows inducing this spaced k-mer.
            for p1, p2 in itertools.combinations(spaced_kmer_occurences[spaced_kmer], 2):
                # Add the pair into the list of candidate matches
                matching_positions.append((p1, p2))

    return matching_positions
#+END_SRC

#+BEGIN_SRC python
# Input: a pair of sequences.
# Output: the average distance
def distance(A, B):
    matching_positions = get_matching_positions([A, B])

    total_distance = 0
    count = 0

    for pa, pb in matching_positions:
        window_a = A[pa:pa+l]
        window_b = B[pb:pb+l]
        total_distance += hamming_distance(pa, pb)
        count += 1

    return total_distance / count
#+END_SRC

* Analysis
- Model: only substitutions, no indels
- Assumption: this is a proxy for genetic distance
- Probability of getting a bad match
- Given a match, expected hamming distance
- Given two random strings with known hamming distance, bound our estimate


** False positives
Given a spaced k-mer of length $l$ and weight $l$, the probability that two independent random


* Results
- Define a metric
  - Compare with /sensitivity/ (see spaced kmer papers)

    *Sensitivity*: given two random strings of length $l$ (typical $128$) with
    relative hamming distance $d$, the
    probability that they share a given spaced kmer.
    Use to discriminated between strings of /low/ and /high/ edit distance: the
    steeper the transition from $0$ to $1$ as the similarity increases, the better.

  - New metric: compute the variance / standard deviation of the expected
    distance. The 'sensitivity' follows from this.

    Equivalently: given two pairs $(A_1, A_2)$ and $(B_1, B_2)$ of relative
    distances $d_A > d_B$, compute
    the probability that $f(A_1, A_2) > f(B_2, B_2)$, where $f$ is our algorithm.

- Results for real and simulated data

* Conclusion
