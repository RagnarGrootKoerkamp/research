#+title: One Billion Row Challenge
#+HUGO_SECTION: posts
#+HUGO_TAGS: performance
#+HUGO_LEVEL_OFFSET: 1
#+OPTIONS: ^:{}
#+hugo_front_matter_key_replace: author>authors
#+toc: headlines 3
#+date: <2024-01-03 Wed>
#+author: Ragnar Groot Koerkamp

Since everybody is doing it, I'm also going to take a stab at the
[[https://www.morling.dev/blog/one-billion-row-challenge/][One Billion Row Challenge]].

Rules I set for myself:
- Rust (of course)
- External libraries are allowed at first for convenience.

This post is a log of ideas, timings, and general progress.

My processor is a =i7-10750H CPU @ 2.6GHz=
- Clock speed is capped at =3.60GHz=. (It can run
at =4.6GHz=, but =3.6GHzz= is more stable for benchmarking.)
- $64GB$ ram.
- It has 6 cores.
- Hyperthreading is disabled initially. (I may try enabling it later.)
- The file should be cached in memory by the OS.

Code is on [[https://github.com/RagnarGrootKoerkamp/1brc][github]].

* Initial solution: 105s
Here's a first version. zero optimizations.
#+begin_src rust
use std::{collections::HashMap, env::args, io::Read};

struct Record {
    count: u32,
    min: f32,
    max: f32,
    sum: f32,
}

impl Record {
    fn default() -> Self {
        Self {
            count: 0,
            min: 1000.0,
            max: -1000.0,
            sum: 0.0,
        }
    }
    fn add(&mut self, value: f32) {
        self.count += 1;
        self.sum += value;
        self.min = self.min.min(value);
        self.max = self.max.max(value);
    }
    fn avg(&self) -> f32 {
        self.sum / self.count as f32
    }
}

fn main() {
    let filename = args().nth(1).unwrap_or("measurements.txt".to_string());
    let mut data = String::new();
    {
        let mut file = std::fs::File::open(filename).unwrap();
        file.read_to_string(&mut data).unwrap();
    }
    let mut h = HashMap::new();
    for line in data.trim().split('\n') {
        let (name, value) = line.split_once(';').unwrap();
        let value = value.parse::<f32>().unwrap();
        h.entry(name).or_insert(Record::default()).add(value);
    }

    let mut v = h.into_iter().collect::<Vec<_>>();
    v.sort_unstable_by_key(|p| p.0);
    for (name, r) in v {
        println!("{name}: {:.1}/{:.1}/{:.1}", r.min, r.avg(), r.max);
    }
}
#+end_src
