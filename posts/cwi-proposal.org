#+title: Research proposal: subquadratic string graph construction
#+hugo_section: posts
#+date:  <2023-07-10>
#+HUGO_LEVEL_OFFSET: 1
#+hugo_front_matter_key_replace: author>authors
#+OPTIONS: ^:{}
#+toc: headlines 3
#+author: Ragnar Groot Koerkamp

This is a research proposal for a 5 month internship at CWI during autumn/winter 2023-2024.

* Introduction

An important problem in bioinformatics is /genome assembly/:
DNA sequencing machines read substrings of a full DNA genome, and these pieces
must be /assembled/ together to recover the entire genome.

Let $k$ be the number of reads and let $R = \{S_1, \dots, S_k\}$ be the set of
reads with total length $n:= |S_1| + \dots + |S_k|$.
An important part of the assembly process is to construct an /assembly graph/ of
all the reads (after first /cleaning/ the reads).
Three approaches to this, ignoring details regarding reverse complements, are [cite:@assembly-challenges]:
1. The /overlap graph/, where each read $S_i$ is a node, and nodes $S_i$
   and $S_j$ are connected by a directed edge $S_i\rightarrow S_j$ with length
   $|S_i| - \ell$ if there is a (sufficiently long) length $\ell$ suffix of $S_i$ that
   equals a prefix of $S_j$.
2. The /string graph/ [cite:@string-graph] is a simplified graph
   containing only the /irreducible/ edges of the overlap graph. I.e. it is the
   smallest graph whose transitive closure is the overlap graph. Also, reads
   contained in other reads are removed.
3. The /De Bruijn/ graph of the reads, which
   contains a node for each /$k$-mer/ present in the set of reads, and
   for each $(k+1)$-mer it adds an edge from its prefix $k$-mer to the suffix
   $k$-mer. Velvet and SPAdes use this approach [cite:@velvet;@spades;@spades-recomb].
After additional cleaning of the graph, the assembled genome is found as a set of paths/walks
through it covering all nodes (for string graphs) or edges (depending on the
exact type of De Bruijn graph used).

In the overlap graph and string graph approach, an important step is to find the
longest suffix-prefix overlap between all pairs of reads $(S_i, S_j)$. Since a
full alignment per pair is slow and long reads are often noisy, this is usually
sped up using an (approximate) /filter/ [cite:@minimap]:
1. BLAST stores $k$-mers per read in a hashmap [cite:@blast] and counts matching
   $k$-mers.
2. DAligner efficiently finds matching $k$-mers between two (sets of) reads by
   merge-sorting the $k$-mers of the two (sets of) reads [cite:@daligner;@efficient-qgram-filters].
3. MHAP sketches the $k$-mers in a sequence using MinHash [cite:@mhap].
4. Minimap sketches the /minimizers/ in a sequence using MinHash [cite:@minimap].

Alternatively, efficient datastructures can be used to compute all exact maximal
pairwise suffix-prefix overlaps:
- Gusfield [cite:@gusfield] gives an $O(n+k^2)$ suffix-tree based algorithm.
- SGA [cite:@sga] uses the FM-index for $O(n)$ time construction of all
  irreducible edges [cite:@assembly-graph-fm].
- Hifiasm [cite:@hifiasm] is unclear but also seems to only use exact
  sufix-prefix matches, given that hifi reads have sufficient quality for exact overlaps.
- [cite/t:@suffix-prefix-queries] takes a different approach and instead of
  computing all (irreducible) pairwise overlaps up-front, it introduces multiple queries:
  - $OneToOne(i,j)$ computes the longest overlap between $S_i$ and $S_j$ in
    $O(\log \log k)$.
  - $OneToAll(i)$: computes the longest overlap between $S_i$ and each other
    $S_j$ in $O(k)$.
  - $Report(i,l)$ reports all overlaps longer than $l$ in $O(\log n +
    output)$[fn::This and the methods below can also be done with $\log n / \log
    \log n$ complexity instead of $\log n$ using more advances geometric algorithms.].
  - $Count(i,l)$ counts the overlaps longer than $l$ in $O(\log n)$.
  - $Top(i,K)$ returns the top $K$ longest overlaps of $S_i$ in $O(\log^2 n + K)$.

* Plan
The plan for this internship is to improve and extend the results of this last
paper, [cite/t:@suffix-prefix-queries]:
1. Improve the complexity of the $Top(i,K)$ to $O(n)$ construction time and
   $O(\log n+K)$ query time.
2. Extend $Top(i,K)$ to the $AllToAll$ setting, to return the top $K$ overlaps
   for each $S_i$.

#+print_bibliography:
