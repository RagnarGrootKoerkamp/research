#+title: Research proposal: subquadratic string graph construction
#+hugo_section: posts
#+date:  <2023-07-10>
#+HUGO_LEVEL_OFFSET: 1
#+hugo_front_matter_key_replace: author>authors
#+OPTIONS: ^:{}
#+toc: headlines 3
#+author: Ragnar Groot Koerkamp

This is a research proposal for a 5 month internship at CWI during autumn/winter 2023-2024.

* Introduction

An important problem in bioinformatics is /genome assembly/:
DNA sequencing machines read substrings of a full DNA genome, and these pieces
must be /assembled/ together to recover the entire genome.

Let $k$ be the number of reads and let $R = \{S_1, \dots, S_k\}$ be the set of
reads with total length $n:= |S_1| + \dots + |S_k|$.
An important part of the assembly process is to construct an /assembly graph/ of
all the reads (after first /cleaning/ the reads).
Three approaches to this, ignoring details regarding reverse complements, are [cite:@assembly-challenges]:
- The /overlap graph/, where each read $S_i$ is a node, and nodes $S_i$
  and $S_j$ are connected by a directed edge $S_i\rightarrow S_j$ with length
  $|S_i| - \ell$ if there is a (sufficiently long) length $\ell$ suffix of $S_i$ that
  equals a prefix of $S_j$.
- The /string graph/ [cite:@string-graph] is a simplified graph
  containing only the /irreducible/ edges of the overlap graph. I.e. it is the
  smallest graph whose transitive closure is the overlap graph. Also, reads
  contained in other reads are removed.
- The /De Bruijn/ graph of the reads, which
  contains a node for each /$k$-mer/ present in the set of reads, and
  for each $(k+1)$-mer it adds an edge from its prefix $k$-mer to the suffix
  $k$-mer. Velvet and SPAdes use this approach [cite:@velvet;@spades;@spades-recomb].
After additional cleaning of the graph, the assembled genome is found as a set of paths/walks
through it covering all nodes (for string graphs) or edges (depending on the
exact type of De Bruijn graph used).

In the overlap graph and string graph approach, an important step is to find the
longest suffix-prefix overlap between all pairs of reads $(S_i, S_j)$. Since a
full alignment per pair is slow and long reads are often noisy, this is usually
sped up using an (approximate) /filter/ [cite:@minimap]:
- BLAST stores $k$-mers per read in a hashmap [cite:@blast] and counts matching
  $k$-mers.
- DAligner efficiently finds matching $k$-mers between two (sets of) reads by
  merge-sorting the $k$-mers of the two (sets of) reads [cite:@daligner;@efficient-qgram-filters].
- MHAP sketches the $k$-mers in a sequence using MinHash [cite:@mhap].
- Minimap sketches the /minimizers/ in a sequence using MinHash [cite:@minimap].

Alternatively, efficient datastructures can be used to compute all exact maximal
pairwise suffix-prefix overlaps:
- Gusfield [cite:@gusfield] gives an $O(n+k^2)$ suffix-tree based algorithm.
- SGA [cite:@sga] uses the FM-index for $O(n)$ time construction of all
  irreducible edges [cite:@assembly-graph-fm].
- Hifiasm [cite:@hifiasm] is unclear but also seems to only use exact
  sufix-prefix matches, given that hifi reads have sufficient quality for exact overlaps.
- [cite/t:@suffix-prefix-queries] takes a different approach and instead of
  computing all (irreducible) pairwise overlaps up-front, it introduces multiple queries:
  - $OneToOne(i,j)$ computes the longest overlap between $S_i$ and $S_j$ in
    $O(\log \log k)$.
  - $OneToAll(i)$: computes the longest overlap between $S_i$ and each other
    $S_j$ in $O(k)$.
  - $Report(i,l)$ reports all overlaps longer than $l$ in $O(\log n +
    output)$[fn::This and the methods below can also be done with $\log n / \log
    \log n$ complexity instead of $\log n$ using more advanced geometric algorithms.].
  - $Count(i,l)$ counts the overlaps longer than $l$ in $O(\log n)$.
  - $Top(i,K)$ returns the top $K$ longest overlaps of $S_i$ in $O(\log^2 n + K)$.

* Plan
The plan for this internship is to improve, extend, and apply the results of this last
paper, [cite/t:@suffix-prefix-queries].

[TODO to improve text]

** Improve query performance using Heavy-Light Decomposition

- Improve the complexity of the $Count(i,l)$ and $Top(i,K)$ to $O(n)$ construction time and
  $O(\log n)$ resp. $O(\log n+K)$ query time:

  It seems that using a heavy-light-decomposition on top of the suffix tree, it is possible to obtain a
  linear time construction that contains sufficient information to answer
  $Count$ and $Top$ queries in $\log n$ time by iterating over components of
  the
- Extend $Top(i,K)$ to the $AllToAll$ setting, to return the top $K$ overlaps
  for each $S_i$.
- Extend $Top(i,K)$ (and other methods) to only return irreducible edges,
  ideally reducing the $output$ component of the query complexity.

** Extend to non-exact suffix-prefix-overlap that allows for read errors
I would like to investigate extensions of these exact algorithms to allow fuzzy
matching in case reads are erroneous with a small (e.g. $2\%$) error rate.

- Short reads are very exact, so exact suffix-overlap detection was sufficient
- Long reads are very noisy (up to $10\%$), so up to $20\%$ read-read overlap
  can be present. This has typically been worked around by using
  $k$-mer/minimizer based filters rather than using datastructure based approaches.
- New hifi reads are up to $10kbp$ long with error rates as low as $0.1\%$ after
  cleaning. This makes datastructure based algorithms useful again. (TODO:
  Investigate exactly what hifiasm does here.)

** Implement an algorithm to build string graphs, and possibly a full assembler

I would like to implement a fast algorithm to build the string graph, based on
the queries provided about and/or existing $O(n+k^2)$ or $O(n+output)$ methods.


#+print_bibliography:
