#+title: [WIP] PtrHash: perfect hashing at the speed of memory
#+filetags: @paper mphf wip
#+OPTIONS: ^:{} num:t
#+hugo_front_matter_key_replace: author>authors
#+toc: headlines 3
#+date: <2024-11-20 Wed>

$$
\newcommand{\part}{\mathsf{part}}
\newcommand{\bucket}{\mathsf{bucket}}
\newcommand{\slot}{\mathsf{slot}}
\newcommand{\reduce}{\mathsf{reduce}}
\newcommand{\h}{\mathsf{h}}
\newcommand{\hp}{\mathsf{h}_{\mathsf{p}}}
\newcommand{\C}{\mathsf{C}}
\newcommand{\free}{F}
$$

This is the work-in-progress paper on PtrHash. The original blog post on its
development is [[../ptrhash][here]].

* Abstract
:PROPERTIES:
:UNNUMBERED:
:END:
*Motivation.*
Given a set $K$ of $n$ keys, a minimal perfect hash function (MPHF) is a
collision-free bijective map $f$ from $K$ to $\{0, \dots,
n-1\}$. These functions have uses in databases, search engines, and are used in
bioinformatics indexing tools such as Pufferfish (using BBHash), and
Piscem (both using PTHash).
Our main motivating usage is that as in SSHash, where PTHash only takes $5\%$ of the
total space.
Thus, this work presents a (minimal) perfect hash function that first prioritizes query
throughput, while also allowing efficient construction for $10^9$ or more elements
using under $3$ bits of memory per key.

*Contributions.*
PtrHash builds on
PTHash by 1) partitioning the table for faster construction, and 2) using cuckoo
hashing to find $8$ bit pilots, which 3) makes further compression redundant. We further
speed up queries by 4) simplifying hash functions and modulo operations, and 5)
streaming multiple queries in parallel and prefetching memory reads.

*Results.*
(TODO: update numbers. TODO: add something about speed of memory) We implemented PtrHash in Rust and
show that at $3$ bits/key memory usage it is $3\times$ faster to construct
than PTHash while achieving $8$ns/key query throughput, $5\times$ faster than
state-of-the-art methods.

*Source:* [[https://github.com/RagnarGrootKoerkamp/ptrhash][github.com/RagnarGrootKoerkamp/ptrhash]]

* Introduction
- *Problem statement*
- Perfect hashing
- Minimal perfect hashing
- Application in bioinformatics (SSHash)
- Focus on query speed/throughput;
  - Only a single RAM access per query, ideally
- Instead of one $n \log_2(e)$  bit number, search for many 8-bit numbers
** Motivation
SSHash, throughput first
** Contributions
We introduce PtrHash, a minimal perfect hash function that is primarily optimized for
query throughput and construction speed, at the cost of some more memory usage.
Its main novelties are:
1. the use of fixed-width $8$ bit pilots, leading to very simple lookups;
2. cuckoo-hashing-like based construction
3. construction in parts, with a single /remap/ table, leading to fast construction;
* Background
- GB vs GiB
** Single large seed.
** Other work
- sichash [cite:@sichash]
- shockhash [cite:@shockhash]
- bipartite shockhash [cite:@bipartite-shockhash]
** Recsplit?
** FCH
** PTHash
** PTHash-HEM
** PHOBIC
** EF coding
*** Uniform Partitioned EF
** Cachelines



* PtrHash

The core principle of PtrHash[fn::The
PT in PTHash stand for /Pilot Table/. The
author of the present paper mistakenly understood it to stand for Pibiri and
Trani, the authors of the PTHash paper. Due to the current author's
unconventional last name, and PTGK not sounding great, the first initial (R) was
appended instead. As things go, nothing is as permanent as a temporary name.
Furthermore, we follow the Google style guide and avoid a long run of uppercase
letters, and write PtrHash instead of PTRHash.]
is to simplify PTHash to speed up both query speed
and construction time, at the cost of possibly using slightly more memory.
We first give a high level overview of PtrHash ([[*Overview]]). Then, we explain
specific parts of PtrHash in more detail.

** Overview

#+name: overview
#+caption: Overview of PtrHash on $n=23$ keys. The keys are hashed into $[H] = [2^{64}]$ and this range is split into $P=2$ parts and $B=5$ buckets per part. In red are four keys hashing to the same bucket in the first part, and in blue are three keys belonging to the same bucket in the second part. The /pilots/ of the $P\cdot B=10$ buckets in the highlighted area are the main component of the data structure, and control to which /slots/ keys in the bucket are mapped to avoid collisions. The blue highlighted key is initially mapped to a position $\geq n$, and thus (along with the other yellow cells) /remapped/ into an empty slot $<n$ via a (compressed) table of free slots.
#+attr_html: :class inset large
[[file:./overview.drawio.svg]]


Before going into details, we first briefly explain the fully constructed
PtrHash data structure and how to query it, see [[overview]] and [[query-code]]. We also
highlight differences to PTHash [cite:@pthash] and PHOBIC [cite:@phobic].

*Parts and buckets.*
The input is a set of $n$ /keys/ $\{k₀, ̣\dots, k_{n-1}\}$ that we want to hash to
$n$ /slots/ $[n]:=\{0, \dots, n-1\}$.
We first hash the keys using a 64-bit hash function $\h$ into
$\{\h(k_0), \dots, \h(k_{n-1})\}$. The total space of hashes $[2^{64}]$
is equally partitioned into $P$ /parts/, and the part of a key is easily found
as $\left\lfloor P\cdot \h(k_i) / 2^{64}\right\rfloor$ [cite:@fast-range].
Then, the expected $n/P$ keys in each part are partitioned into $B$ non-uniform /buckets/:
each key has a /relative position/ $x$ inside the part, and this is passed through
a /bucket
assignment function/ $\gamma: [0,1)\mapsto[0,1)$ such as $x\mapsto x^2$
that controls the distribution of expected bucket
sizes [cite:@phobic], as explained in detail in [[#bucket-fn]].
The result is then scaled to a bucket index in $[B]$:
\begin{align}
\begin{split}
  \part(k_i) &:= \left\lfloor P\cdot \h(k_i) / 2^{64}\right\rfloor,\\
  x &:= \big((P\cdot \h(k_i)) \bmod 2^{64}\big)/2^{64},\\
  \bucket(k_i) &:= \left\lfloor B\cdot \gamma(x)\right\rfloor.
\end{split}\label{eq:partbucket}
\end{align}

*Slots and pilots.*
Now, the goal and core of the data structure is to map the $n/P$ expected keys in each part to $S\approx
(n/P)/\alpha$ /slots/, where $\alpha\approx 0.99$ gives us $\approx 1\%$ extra slots to
play with. The pilot for each bucket controls to which slots its keys map.
PtrHash uses fixed-width $8$-bit /pilots/ $\{p_0, \dots,
p_{P\cdot B-1}\}$, one for each bucket. Specifically, key $k_i$ in bucket $b=\bucket(k_i)$ with pilot $p_b$
maps to slot
\begin{equation}
  \slot(k_i) := \part(k_i) \cdot S + \reduce(\h(k_i) \oplus \hp(p_b), S),\label{eq:slot}
\end{equation}
where $\reduce(\cdot, S)$ maps the random $64$ bit integer into $[S]$ as explained below.

Compared to PHOBIC and PTHash(-HEM) [cite:@pthash-2], there are two differences
here.
First, while we still split the input into parts, we assign each part the
/same/ number of slots, instead of scaling the number of slots with the
/actual/ size of each part. At query time, this removes the need to look up the
size of the key's part. Second, previous methods search for arbitrary large
pilot values that require some form of compression to store efficiently. Our
8-bit pilots can simply be stored in an array so that lookups are simple.

We now go over some specific details.

*Hash functions.*
The 8-bit pilots $p_b$ are hashed into pseudo-random $64$ integers by
using FxHash for $\hp$,
which simply multiplies the pilot with a /mixing constant/ $\C$:
\begin{equation}
\hp(p) := \C \cdot p.
\end{equation}

When the keys are $64$ bit integers, we use this same FxHash algorithm to hash
them ($\h(k) := \C\cdot k$), since multiplication by an odd constant is invertible modulo $2^{64}$ and
hence collision-free.
For other types of keys, the hash function depends on the number of elements. When the
number of elements is not too far above $10^9$, the probability of hash
collisions with a $64$ bit hash function is sufficiently small, and we use
the $64$ bit variant of xxHash[fn::[[https://xxhash.com][xxhash.com]]].
When the number of keys goes beyond $2^{32} \approx 4\cdot 10^9$, the
probability of $64$ bit hash collisions increases. In this case, we use the
$128$ bit variant of xxHash.
The high $64$ bits determine the part and bucket in Equation \ref{eq:partbucket}, and the low
$64$ bits are used in Equation \ref{eq:slot} to determine the slot.

*The reduce function.* When $64$ bit hashes are used, we must ensure that all bits of
the hash are used to avoid collisions. A simple choice would be $\reduce(x,S) = x\bmod S$, which uses
all bits when $S$ is /not/ a power of $2$ and takes two multiplications using
'fast mod' [cite:@fast-mod]. Instead, we use $S=2^s$, so that $x\bmod 2^s$ is a simple bit-mask. Unfortunately, this only uses
the lower $s$ bits of the hash, while the $part$ and $bucket$ functions use the
high $\log_2(P\cdot B)$ bits, leaving some entropy in the middle bits unused.

As a solution, we first multiply $x$ by the mixing constant $\C$, and then take the low
$s$ bits of the high half. This uses all input bits and
only needs a single multiplication, giving a small speedup over fast mod:
\begin{equation}
  \reduce(x, 2^s) := \left\lfloor \C\cdot x/2^{64}\right\rfloor \bmod 2^s.
\end{equation}

*Remapping.* Since each part has slightly ($\approx 1\%$) more slots than keys, some keys will map to an
index $\geq n$, leading to a /non-minimal/ perfect hash function. To fix this,
those are /remapped/ back into the 'gaps' left behind in slots $<n$ using a
(possibly compressed) lookup table. This is explained in detail in [[#remapping]].

Whereas PTHash-HEM uses a separate remap /per part/, PtrHash only has a single
'global' remap table.

*Construction.* The main difficulty of PtrHash is during construction ([[#construction]]), where we must find values of the
pilots $p_j$ such that all keys indeed map to different slots.
Like other methods, PtrHash processes multiple parts in parallel.
Within each part, it sorts the buckets from large to
small and 'greedily' assigns them the smallest pilot value that maps the keys in
the bucket to slots that are still free.
Unlike other methods though, PtrHash only allows pilots up to $255$. When no
suitable pilot is found, we use a method similar to (blocked) cuckoo hashing
[cite:@cuckoo-hashing]: a pilot with a minimal number of collisions is chosen,
and the colliding buckets are 'evicted' and will have to search for a new pilot.

*Parameter values.*
In practice, we usually use $\alpha=0.99$.
Similar to PHOBIC, the number of buckets per part is set to $B = (\alpha\cdot
S)/\lambda$, where $\lambda$ is the expected size of each bucket and is around
$3$ to $4$.
The number of parts is $P=\lceil n/(\alpha S)\rceil$.
Smaller parts fit better in cache and hence are faster to construct, while too
small parts have too much variance in their size, causing some parts to possibly have
more than $S$ keys in them. Thus, we choose $S$ as the smallest size for which
the probability that any part is over-subscribed is sufficiently small.

*Streaming queries.* PtrHash supports /streaming/ queries, where multiple
queries are processed in parallel. This enables us to prefetch pilots from
memory, and thus increase throughput and better use the available memory bandwidth.

#+name: parameters
#+caption: Input parameters with typical values, and computed variables.
| Name                                                                  | Definition                                                        |
| $\alpha = 0.99$                                                       | Load factor. Expected number of keys per part is $\alpha\cdot S$. |
| $\lambda=4$                                                           | Expected number of elements per bucket.                           |
| $\gamma(x) = \frac{255}{256}\cdot (x^2+x^3)/2 + \frac{1}{256}\cdot x$ | Bucket function controlling relative bucket sizes.                |
| $n$                                                                   | Total number of keys.                                             |
| $S = 2^{18}$                                                          | Number of slots per part.                                         |
| $P = \lceil n/(\alpha \cdot S)\rceil$                                 | Number of parts.                                                  |
| $B = \lceil(\alpha \cdot S)/\lambda\rceil$                            | Number of buckets per part.                                       |

#+name: query-code
#+caption: Rust code for a simple implementation of the data structure and query function.
#+begin_src rust
struct PtrHash {
    n: usize,         // Number of elements
    P: usize,         // Number of parts
    B: usize,         // Buckets per parts
    S: usize,         // Slots per parts
    lgS: usize        // S = 2^lgS
    pilots: Vec<u8>,  // P*B pilots
    free: Vec<usize>, // P*S-n remap indices
}

/// Multiply a and b as if they are fractions of 2^64.
/// Compiles to taking the high 64 bits of the 64x64->128 multiplication.
fn mul(a: usize, b: usize) -> usize {
    ((a as u128 * b as u128) >> 64) as usize
}

impl PtrHash {
    fn query(&self, key: Key) -> usize {
        let h = self.hash(key);
        let part = mul(self.P, h);
        let bucket = mul(self.B, self.gamma(self.P * h));
        let pilot = self.pilots[bucket];
        let slot_in_part = mul(self.C, h ^ self.hash_pilot(pilot)) & (self.S - 1);
        let slot = (part << self.lgS) + slot_in_part;
        if slot < self.n {
            return slot
        } else {
            return self.free[slot - self.n]
        }
    }
}
#+end_src

** Construction
:PROPERTIES:
:CUSTOM_ID: construction
:END:
Both PTHash-HEM and PHOBIC first partition the keys into parts, and then build
an MPHF part-by-part, optionally in parallel on multiple threads.
Within each part, the keys are randomly partitioned into
/buckets/ of average size $\lambda$ ([[overview]]).
Then, the buckets are sorted from large to small, and one-by-one /greedily/ assigned a
/pilot/, such that the keys in the bucket map to /slots/ not yet covered by earlier buckets.

As more buckets are placed, there are fewer remaining empty slots, and searching for pilots becomes harder.
Hence, PTHash uses $n/\alpha > n$ slots
to ensure there sufficiently many empty slots for the last pilots. This speeds
up the search and reduces the values of the pilots.
PHOBIC, on the other hand, uses relatively small parts of size $2500$, so that
the search for the last empty slot usually shouldn't take much more than $2500$ attempts.
Nevertheless, a drawback of the greedy approach is that pilots values have an uneven
distribution, making it hard to compress them efficiently.

*Hash-evict[fn::We would have preferred to call this method hash-displace, as
/displace/ is the term used instead of /evict/ in e.g. the cuckoo  filter by [cite/t:@cuckoo-filter].
Unfortunately, /hash and displace/ is also the name of another MPHF introduced
by [cite/t:@hash-displace], that was then extended into /compressed
hand-and-displace/ (CHD) by [cite/t:@hash-displace-compress]. There, the
to-be-inserted key (rather than the existing key) is /displaced/ by applying a linear shift
to its initial position.].* In PtrHash, we instead use /fixed width/, single byte pilots. To achieve
this, we use a technique resembling cuckoo hashing [cite:@cuckoo-hashing], as
shown in [[construction-code]].
As before, buckets are greedily /inserted/ from large to small. For some buckets,
there may be no pilot in $[255]$ such that all its keys map to empty slots. When
this happens, a pilot is found with the lowest weighted number of /collisions/.
The weight of a collision with an element of a bucket of size $s$ is $s^2$, to prevent
/evicting/ large buckets, as those are harder to place.
The colliding buckets are evicted by emptying the slots they map to and
pushing them back onto the priority queue of remaining buckets.
Then, the new bucket is inserted.

#+name: construction-code
#+caption: Conceptual Rust code for determining the pilot values for each part. In practice, a number of optimizations are made.
#+begin_src rust
/// Given the buckets of hashed keys for a part, search for pilot values.
fn pilots_for_part(&self, buckets: Vec<&[Hash]>) -> Vec<u8> {
    let mut pilots = vec![0; self.B];                    // One pilot per bucket.
    let mut slots = vec![None; self.S];       // Bucket idx mapping to each slot.

    // A priority queue (max-heap) of buckets.
    let mut queue = BinaryHeap::from_iter(
        (0..buckets.len()).iter().map(|i| (buckets[i].len(), i))
    );

    while let Some((_, i)) = queue.pop() {       // Insert next-largest bucket i.
        pilots[i] = self.find_pilot(buckets[i], &mut slots);
        for &h in buckets[i] {
            let slot = self.slot_for_hashed_key(h, pilots[i]);
            if let Some(j) = slots[slot] {           // Evict colliding bucket j.
                for &h_j in buckets[j] {
                    let slot_j = self.slot_for_hashed_key(h_j, pilots[j]);
                    slots[slot_j] = None;
                }
                todo.push((buckets[j].len(), j));
            }
            slots[slot] = Some(i);
        }
    }

    pilots
}
#+end_src

[APPENDIX] *Optimizations.* In order to speed up the code to search for pilots, a number of
optimizations are made to the conceptual idea of [[construction-code]].
1. *=taken= bit mask.* Instead of determining whether a slot is free by
   checking the =slots= array for the optional index of the bucket mapping
   there, we keep a separate bit mask =taken= that takes only $1$ bit instead
   of $32$ bits per element. This allows for better caching and hence faster access.
2. *Collision-free hot path.* When searching for pilots, we first test if there
   is a pilot without any collisions. This is usually the case, and is faster
   since it only needs access to =taken=, not =slots=. Additionally, where there
   /is/ a collision, we know a pilot is optimal when it collides with exactly
   one bucket of minimal size.
3. *Avoiding loops.* To avoid repeated patterns of the same buckets evicting
   each other, the search for a pilot starts at a random number in $[256]$,
   rather than at $0$.
4. *Avoiding loops more.* Each time a bucket is placed that evicted some other
   bucket(s), it is added to a list of the $16$ most recently placed buckets.
   Buckets in this list are never evicted. This avoids short cycles, where for
   example two buckets keep evicting each other for the same slot.

*Analysis.* Unfortunately, we do not currently have a formal analysis showing
that the hash-evict method works with high probability given that certain
criteria are met. In [[*Results]], we will show some practical results.

** Remapping using CacheLineEF
:PROPERTIES:
:CUSTOM_ID: remapping
:END:
Like PTHash, PtrHash uses a parameter $0<\alpha\leq 1$ to use a total of
$n'=n/\alpha$ slots, introducing $n'-n$ additional free slots.
As a result of the additional slots, some, say $R$, of the keys will map to positions $n\leq
q_0<\dots< q_{R-1}< n'$, causing the perfect hash function to not be /minimal/.

*Remapping.* Since there are a total of $n$ keys, this means there are exactly $R$ empty
slots ('gaps') left behind in $[n]$, say at positions $L_0$ to $L_{R-1}$.
We /remap/ the keys that map to positions $\geq n$ to the empty slots at
positions $< n$ to obtain a /minimal/ perfect hash function.

A simple way to store the remap is as a plain array $\free$, such that
$\free[q_i-n] = L_i$.
PTHash encodes this array using Elias-Fano coding [cite:@elias;@fano], after setting undefined
positions of $\free$ equal to their predecessor.
The benefit of a plain $\free$ array is fast and cache-local lookups, whereas
Elias-Fano coding provides a more compact encoding that requires multiple
lookups to memory.

*CacheLineEF.* We propose using Elias-Fano coding on a per-cache line basis, so that each
lookup only requires a single read from memory.
First, the list of non-decreasing $\free$ positions is split into chunks of
$C=44$ values $\{v_0, \dots, v_{43}\}$, with the last chunk possibly containing fewer values.
Then, each chunk is encoded into $64$ bytes that can be stored as single cache
line, as shown in [[cacheline-ef]].

We first split all indices into their $8$ /low/ bits ($v_i \bmod 2^8$) and $32$
/high/ bits ($\lfloor v_i/2^8\rfloor$). Further, the high part is split into an
/offset/ (the high part of $v_0$) and the /relative/ high part:
\begin{equation}
v_i =
2^8\cdot\underbrace{\lfloor v_0/256\rfloor}_{\text{Offset}} +
2^8\cdot \underbrace{\left(\lfloor v_i/256\rfloor - \lfloor
v_0/256\rfloor\right)}_{\text{Relative high part}}
+\underbrace{(v_i\bmod 2^8)}_{\text{Low bits}}.
\label{eq:clef}
\end{equation}
This is stored as follows.
- First, the $32$ bit offset $\lfloor v_0/256\rfloor$ is stored.
- Then, the relative high parts are encoded into $128$ bits. For each $i\in[44]$, bit $i + \lfloor
  v_i/256\rfloor - \lfloor v_0/256\rfloor$ is set to =1=.
  Since the $v_i$ are increasing, each $i$ sets a distinct bit, for a total of $44$ set bits.
- Lastly, the low $8$ bits of each $v_i$ are directly written to the $44$ trailing bytes.

#+name: cacheline-ef
#+caption: Overview of the CacheLineEF datastructure.
#+attr_html: :class inset large
[[file:./cacheline-ef.drawio.svg]]

*Lookup.* The value at position $i$ is found by summing the terms of Equation
\ref{eq:clef}. The offset and low bits can be read directly.
This relative high part can be found as $256\cdot(select(i)-i)$, where $select(i)$ gives
the position of the $i$'th =1= bit. In practice, this can be implemented
efficiently using the =PDEP= instruction provided by the BMI2 bit manipulation
instruction set [cite:@fast-select]:
[DROP?] this operation can /deposit/ the mask =1<<i= onto our bit pattern, so that the
=1= ends up at the position of the $i$'th one of our pattern. Then, it suffices
to count the number of trailing zeros, which is provided by the =TZCNT=
instruction in BMI1.

*Limitations.* CacheLineEF uses $64/44\cdot 8 = 11.6$ bits per value, which is
more than the usual Elias-Fano, which for example takes $8+2=10$ bits per value for data
with an average stride of $256$.
Furthermore, values are limited to $40$ bits, covering $10^{12}$ items.
The range could be increased to $48$ bit numbers by storing $5$ bytes of the
offset, but this has not been necessary so far.
Lastly, each CacheLineEF can only span a range of around $(128-44)\cdot 256 =
21\ 504$, or an average stride of $500$.
This means that for PtrHash, we must use $\alpha\leq 0.998$, so that the
average distance between empty slots is at most $500$.

[DROP?] *Comparison.*
Compared to Elias-Fano coding, CacheLineEF stores the low order bits as exactly
a single byte, removing the need for unaligned reads. Further, the select
data structure on the high-order bits is replaced by a few local bit-wise operations.
CacheLineEF is also somewhat similar to the /(Uniform) Partitioned Elias-Fano Index/
of [cite/t:@partitioned-elias-fano], in that both split the data.
The uniform partitioned index also uses fixed part sizes, but encodes them with
variable widths, and adds a second level of EF
to encode the part offsets. Instead, CacheLineEF prefers simplicity and uses
fixed part sizes with a constant width encoding and simply stores the offsets directly.


#+name: cacheline-ef-code
#+caption: Code for constructing and querying CacheLineEF.
#+attr_html: :class inset large
#+begin_src rust
const L: usize = 44; // The number of elements per cache line.

#[repr(C)]
#[repr(align(64))]   // Align the 64byte object to cache lines.
pub struct CacheLineEF {
    high: [u64; 2],  // Encoding of the high bits.
    offset: u32,     // Offset of the first element.
    low: [u8; L],    // Low 8 bits of each element.
}

impl CacheLineEF {
    fn new(vals: &[u64; L]) -> Self {
        let offset = vals[0] >> 8;
        let mut low = [0u8; L];
        for (i, &v) in vals.iter().enumerate() {
            low[i] = (v & 0xff) as u8;
        }
        let mut high = [0u64; 2];
        for (i, &v) in vals.iter().enumerate() {
            let idx = i + ((v >> 8) - offset) as usize;
            high[idx / 64] |= 1 << (idx % 64);
        }
        Self {
            offset: offset as u32,
            high,
            low,
        }
    }

    fn get(&self, idx: usize) -> u64 {
        let p = self.high[0].count_ones() as usize;
        // Select the position of the 1 using the BMI2 PDEP instruction.
        let one_pos = if idx < p {
            self.high[0].select_in_word(idx)
        } else {
            64 + self.high[1].select_in_word(idx - p)
        };

        self.low[idx] as u64
            + 256 * self.reduced_offset as u64
            + 256 * (one_pos - idx) as u64
    }
}
#+end_src

** Bucket assignment functions
:PROPERTIES:
:CUSTOM_ID: bucket-fn
:END:

#+name: bucket-fn
#+caption: The left shows various bucket assignment functions $\gamma$, such as the piecewise linear function (skewed) used by FCH and PTHash, and the optimal function introduced by PHOBIC. Flatter slopes at $x=0$ create larger buckets, while steeper slopes at $x=1$ create more small buckets, as shown on the right, as the distribution of expected bucket sizes given by $(\gamma^{-1})'$ when the expected bucket size is $\lambda=4$.
| [[file:plots/bucket-fn.svg]] | [[file:plots/bucket-size.svg]] |

During construction, slots slowly fill up as more buckets are
placed. Because of this, the first buckets are much easier to place than the
later ones, when only few empty slots are left.
To compensate for this, we can introduce an uneven distribution of bucket
sizes, so that the first buckets are much larger and the last buckets
are smaller.
FCH [cite:@fch] accomplishes this by a /skew/ mapping that assigns $60\%$ of the
elements to $30\%$ of the
buckets, so that those $30\%$ are /large/ buckets while the remaining $70\%$
is /small/ ([[bucket-fn]]). This is also the scheme used by PTHash.

*The perfect bucket function.*
PHOBIC [cite:@phobic] provides a more thorough analysis and uses the optimal[fn::Under the
assumption that bucket sizes are continuous, and that the target load factor is
$\alpha=1$.] function
$\gamma_p(x) = x + (1-x)\ln (1-x)$. This function has derivative $0$ at $x=0$, so
that many $x$ values map close to $0$.
In practice, this causes the largest buckets to have size much larger than $\sqrt S$.
Such buckets are hard to place, because by the birthday paradox they are likely
to have multiple elements hashing to the same slot. To fix this, PHOBIC ensures the
slope of $\gamma$ is at least $\varepsilon=1/(5 \sqrt S)$ by using
$\gamma_\varepsilon(x) = x + (1-\varepsilon)(1-x)\ln(1-x)$ instead.
Since this function is slow to compute in practice, a
$2048$-piecewise linear approximation is used instead, using a lookup table and linear interpolation.

*Approximations.*
For PtrHash, we would like to only use simple computations and avoid lookups as
much as possible, to avoid the CPU becoming a bottleneck in query throughput.
To this end, we replace the $\ln (1-x)$ by its
first order Taylor approximation at $x=0$, $\ln(1-x) \approx -x$, giving
the quadratic $\gamma_2(x) = x^2$. Using the second order approximation $\ln(1-x) \approx
-x-x^2/2$ results in the cubic $\gamma(x) = (x^2+x^3)/2$. This version again
suffers from too large buckets, so in practice we use $\gamma_3(x) =
\frac{255}{256}\cdot (x^2+x^3)/2 + \frac{1}{256}\cdot x$.

These values can all be computed efficiently by using that the input and output
of $\gamma$ are $64$ bit unsigned integers representing a fraction of $2^{64}$,
so that e.g. $x^2$ can be computed as the upper $64$ bits of the widening $64\times64\to 128$ bit
product $x\cdot x$.

[TODO: $\alpha$-adjusted perfect function.]


** Parallel queries
*Throughput.*
In practice in bioinformatics applications such as SSHash, we expect many
independent queries to the MPHF. This means that queries can be answered in
parallel, instead of one by one. Thus, we should optimize for query /throughput/
(queries per second, but usually implicitly reported as /inverse throughput/ in amortized
seconds per query) rather than individual query latency (seconds per query).

*Out-of-order execution.*
An MPHF on $10^9$ keys requires memory at least $1.5\mathrm{bits}/\mathrm{key} \cdot 10^9
\mathrm{keys} = 188MB$, which is much larger than the L3 cache of size around
$16MB$. Thus, most queries require reading a pilot from main memory (RAM), which usually
has a latency around $80ns$.
Nevertheless, existing MPHFs such as FCH [cite:@fch] achieve an inverse throughput as
low as $35ns/query$ on such a dataset [cite:@pthash].
This is achieved by /pipelining/ and the /reorder buffer/.
For example, Intel Skylake CPUs can execute over $200$ instructions ahead while waiting for memory
to become available [cite:@measuring-rob;@measuring-rob-skylake]. This allows the CPU to already start processing 'future'
queries and fetch the required cache lines from RAM while waiting for the
current query. Thus, when each iteration requires less than $100$ instructions
and there are no branch-misses, this effectively makes up to two reads in
parallel. A large part of speeding up queries is then to reduce the length of
each iteration so that out-of-order execution can fetch memory more iterations ahead.

*Prefetching.*
Instead of relying on the CPU hardware to parallellize requests to memory, we can also
explicitly /prefetch/[fn::There are typically multiple types of prefetching
instructions that prefetch into a different level of the cache hierarchy. We
prefetch into all levels of cache using =prefetcht0=.] cache lines from our code.
Each prefetch requires a /line fill buffer/ to store the result before it is
copied into the L1 cache. Skylake has $12$ line fill buffers
[cite:@line-fill-buffer-skylake], and hence can support up to $12$ parallel
reads from memory.
This gives a maximal throughput around $80ns/12 = 6.67 ns$ per query when each query only requires a single read from main memory.

We consider two models to implement prefetching: batching and streaming.

#+name: streaming
#+caption: [DROP?] Simplified schematic of in-progress reads from main memory (RAM) when using two different prefetching approaches processing (up to) $8$ reads in parallel. Each horizontal line indicates the duration a read is in progress, from the moment it is prefetched (left vertical bar) to the moment it is available in L1 cache and its corresponding line fill buffer is free again (right vertical bar). Streaming (right) provides better parallellism than batching (left).
#+attr_html: :class inset
[[file:./streaming.drawio.svg]]

*Batching.*
In this approach, the queries are split into batches (chunks) of size
$B$, and are then processed one batch at a time ([[streaming]], left).
In each batch, two passes are made over all keys.
In the first pass, each key is hashed, its
bucket it determined, and the cache line containing the corresponding pilot is prefetched.
In the second pass, the hashes are iterated again, and the corresponding slots are
computed.

*Streaming.*
A drawback of batching is that at the start and end of each batch, the
memory bandwidth is not fully saturated.
Streaming fixes this by prefetching the cache line for the pilot $B$ iterations
ahead of the current one, and is able to sustain the maximum possible number of
parallel prefetches throughout, apart from at the very start and end ([[streaming]], right).


** Sharding

When the number of keys is large, say over $10^{10}$, their 64-bit (or 128-bit) hashes may not all fit
in memory at the same time, even though the final PtrHash datastructure (the
list of pilots) would fit. Thus, we can not simply sort all hashes in
memory to partition them. Instead, we split the set of all $n$ hashes into, say
$s=\lceil n/2^{32}\rceil$ /shards/ of $\approx 2^{32}$ elements each,
where the $i$'th shard corresponds to hash values in $s_i:=[2^{64}\cdot i/s,
2^{64}\cdot (i+1)/s)$.
Then, shards are processed one at a time. The hashes in each shard are
sorted and split into parts, after which the parts are constructed as usual.
This way, the shards only play a role during construction, and the final
constructed data structure is independent of which sharding strategy was used.

*In-memory sharding.*
The first approach to sharding is to iterate over the set of keys $s$ times.
In the $i$'th iteration, all keys are hashed, and only those hashes in the
corresponding interval $s_i$ are stored and processed.
This way, no disk space is needed for construction.

*On-disk sharding.*
A drawback of the first approach is that keys are potentially hashed many times.
This can be avoided by writing hashes to disk. Specifically, we can create one
file per shard and append hashes to their corresponding file.
These files are then read and processed one by one.

*Hybrid sharding.* A hybrid of the two approaches above only requires disk space
for $D<s$ shards. This iterates and hashes the keys $\lceil s/D\rceil$ times,
and in each iteration writes hashes for $D$ shards to disk. Those are then
processed one by one as before.

*On-disk PtrHash.*
When the number of keys is so large that even the pilots do not fit in memory, they
can also be stored to disk and read on-demand while querying. This is supported using $\varepsilon$-serde [cite:@epserde;@webgraph].


* Results
In this section we investigate PtrHash construction and query throughput for
different parameters, and compare PtrHash to competitors.
All experiments are run on an Intel Core i7-10750H CPU with 6 cores and
hyper-threading disabled.
The frequency is pinned to 2.6GHz.
Cache sizes are 32KiB L1 and 256KiB L2 per core, and 12MiB shared L3 cache. Main
memory is 64GiB DDR4 at 3200MHz, split over two 32GiB banks.

*Input data.*
For construction, all  experiments use  $10^9$ keys, for which the pilots take
around 300MB and are much larger than L3 cache.
For the query throughput experiments, we also test on
20 million keys, for which the pilots take around
6MB and easily fit in L3 cache.
To avoid the time needed for hashing keys, and since our motivating application
is indexing $k$-mers that fit in $64$ bits, we always use random $64$ bit integer keys, and hash them using FxHash.

*Parameter overview.*
The number of slots per part $S$ is fixed to $2^{20}$. Slightly smaller parts of
$S=2^{18}$ slots results in up to $20\%$ faster construction times because of
better cache locality. However, this turns out to be less reliable when the number of keys
and parts is large, because the variance in number of keys per part is large
enough to have parts with load factor too close to $1$ for construction to
succeed, or even $>1$.

The load factor $\alpha$ ranges from $0.98$, which is sufficiently small to
allow fast construction, to $0.995$, which is about as large as possible to
still allow buckets of size $1$ to find a pilot within $256 tries.

Overall, we propose two sets of parameters, /simple/ and /compact/.

** Construction
:PROPERTIES:
:CUSTOM_ID: construction-eval
:END:
*** Bucket functions

#+name: bucket-fn-plot
#+caption: Bucket size distribution (red) and average number of evictions (black) per additionally placed bucket during construction of the pilot table, for different bucket assignment functions. Parameters are $n=10^9$ keys, $S=2^{18}$ slots per part, and $\alpha=0.98$, and the red shaded load factor ranges from $0$ to $\alpha$. On the left (first five plots), $\lambda=3.5$ so that the pilots take $2.29$ bits/key. For all methods, placing buckets of size $1$ is fast due to the load factor $\alpha<1$, and the bottleneck is placing the last buckets of size $2$ and $3$. Cubic has the least amount of evictions, and hence is fastest to construct. For $\lambda=4.0$ (rightmost plot), the linear, skewed, and optimal bucket assignment functions cause endless evictions, and construction fails. The cubic function does work, resulting in $2.0$ bits/key for the pilots.
#+attr_html: :class full-width
| [[file:plots/bucket_fn_stats_l35.svg]] | [[file:plots/bucket_fn_stats_l40.svg]] |

- Linear is simple
- Cubic is best for construction
- In the remainder, we use linear for speed and simplicity (especially for small
  datastructures), and cubic for space efficiency.

*** Construction and size
#+name: construction
#+caption: Construction size and time TODO: space with =Vec<u32>= alongside =CachelineEf=
#+attr_html: :class inset
[[file:plots/size.svg]]
- $n=10^9$
- $\alpha \in \{0.98, 0.99, 0.995\}$
  - Larger alpha such as $0.995$ are not reliable:
    - too sparse for cacheline ef
    - overly large parts for large n
- bucket functions linear and cubic
- lambda variable $\{3.0, ..., 4.5\}$
- remap using CacheLineEF
- time using 6 threads.
- observations:
  - construction time grows exponentially, until it fails
  - fails usually because eviction chains become too long.
  - cubic can handle much large $\lambda$, and makes smaller overall size
  - $\alpha=0.98$ is faster, but around $0.1bit/key$ larger
  - $\alpha=0.99$ fails before $\alpha=0.98$, partially because for large $n$,
    there will be variance in slots per part, and some parts will have load
    factor too close to $1$, or even larger than $1$.
- $\alpha=0.999$ would
*Slots per part.*
- remark that $2^{18}$ is up to $20\%$ faster to construct, but has too large variance for
  $n=10^{12}$ keys.
*Construction time breakdown.*
- What are these $20ns$ spent on?
  - 1ns hashing
  - 5ns radix sorting
  - 12ns finding pilots
  - 1ns remapping
*Recommended parameters.*
- two proposed configurations:
  - Simple: Linear, $\lambda = 3.0$, $\alpha=0.99$, 2.79 bits/key
    - when $n$ is small and memory doesn't matter too much
  - Compact: Cubic, $\lambda = 4.0$, $\alpha=0.98$, 2.24 bits/key
    (for large $\lambda$ we avoid $\alpha=0.99$ since it is less reliable)

*** Remap
#+name: remap
#+caption:
| Parameters                                            | Pilots (bits/key) | q1_phf | q32_phf | remap_type  | remap | q1_mphf | q32_mphf |
|-------------------------------------------------------+-------------------+--------+---------+-------------+-------+---------+----------|
| simple: $\alpha=0.99$, $\lambda=3.0$, $\gamma$ linear |              2.67 |  14.01 |    8.57 | Vec < u32 > |  0.33 |   12.56 |     8.80 |
|                                                       |                   |  13.80 |    8.58 | CacheLineEF |  0.12 |   12.77 |     9.19 |
|                                                       |                   |  13.91 |    8.65 | EF          |  0.09 |   14.37 |     9.84 |
| compact: $\alpha=0.98$, $\lambda=4.0$, $\gamma$ cubic |              2.00 |  17.82 |    8.07 | Vec < u32 > |  0.66 |   20.37 |     9.11 |
|                                                       |                   |  17.83 |    8.00 | CacheLineEF |  0.24 |   20.97 |    10.45 |
|                                                       |                   |  18.32 |    8.33 | EF          |  0.17 |   23.17 |    14.14 |

#+name: remap-new
#+caption:
| alpha | lambda | bucketfn | pilots | q1_phf | q32_phf | remap_type  | remap | q1_mphf | q32_mphf |
|-------+--------+----------+--------+--------+---------+-------------+-------+---------+----------|
| 0.995 |  3.000 | Linear   |  2.668 | 13.713 |   8.575 | Vec < u32 > | 0.179 |  12.164 |    8.707 |
| 0.995 |  3.000 | Linear   |  2.668 | 13.779 |   8.588 | EF          | 0.056 |  13.400 |    9.199 |
| 0.990 |  4.000 | CubicEps |  2.000 | 17.663 |   7.841 | Vec < u32 > | 0.330 |  19.514 |    8.427 |
| 0.990 |  4.000 | CubicEps |  2.000 | 17.707 |   7.933 | CacheLineEF | 0.120 |  19.857 |   10.520 |
| 0.990 |  4.000 | CubicEps |  2.000 | 17.711 |   7.941 | EF          | 0.094 |  20.841 |   11.110 |

- Remap:
  - plain vec of =u32=
  - cachelineef
  - ef
- observations:
  - CLEF is 2.75x smaller than plain vec
  - CLEF is only 1.4x larger than EF
  - CLEF has slightly slower queries, than plain vec, but much faster than EF,
    both when doing queries one at a time and with explicit streaming and prefetching.
- Params:
  - Simple: =Vec<u32>=
  - Compact: =CacheLineEF=
*** Sharding
- Use $2^{20} \approx 10^6$ slots per part, to avoid having parts with more keys
  than slots (even for $\alpha=0.99$):
  - Say there are $n=\alpha\cdot 10^{12}$ keys and $S=10^6$ slots per part, and
    $P=n/S$ parts.
  - keys per part distribution: $Binom(n, p=1/P)\sim N(np, np(1-p))$, so stddev
    $\sqrt(np(1-p))\approx \sqrt(n/P) =1000$. With $\alpha=0.99$ and $990000$
    keys/part expected with $10000$ buffer, that's $10\sigma$ space, which is
    plenty for a reliable construction.
- 5*10^10:
  - 24 shards
  - In-memory: 3314s
  - Hybrid: 3996s
  - pilots: ~82s/shard
  - sorting buckets: ~15s/shard
  - hybrid: ~45s/shard to hash/write/read keys
    - 197s to hash + write *1/8
    - 21s to read
  - memory: ~65s/shard to re-hash all keys
  - Around 50GB of RAM needed.
    - 12.8GB pilots
    - 6.3GB taken bitvec
  - size:
    - pilots: 2.05 bits/key
    - remap: 0.12 bits/key
    - total: 2.17 bits/key, 13.6GB
  - 10^11 and larger would be possible with support for constructing the
    datastructure itself on disk instead of in memory.
** Query throughput
- Latency around 80ns
- Max single-threaded throughput:
- Max RAM transfer rate: 25.6GB/s
- Single bucket size vs 2-way split vs PHOBIC
  - Construction speed
  - Sequential lookup
  - Prefetching


*** A note on benchmarking query throughput
To our knowledge, all recent papers on (minimal) perfect hashing measure query
speed by first creating a list of keys, and then querying all keys in the list,
as shown in [[query-throughput-1]]. One might think this measures the average
latency of a query, but that is not the case, as the CPU will execute
instructions from adjacent iterations at the same time.
Indeed, as we will see (TODO table ref), this loop can be as fast as $12
ns/key$ for $n=10^9$, which is over $6$ times faster than the RAM latency of $\approx 80ns$,
and thus, at least $6$ iterations are being processed in parallel.

Hence, we argue that existing benchmarks measure (and optimize for)
throughput and that they assume that the list of keys to query is known in advance.
We make this assumption explicit by changing the API to benchmark all queries at
once, as shown in [[query-throughput-2]]. This way, we can explicitly process
multiple queries in parallel as described in [[*Parallel queries]].

We also argue that properly optimizing for throughput is relevant for
applications. SSHash, for example, queries all minimizers of a DNA sequence,
which can be done by first computing and storing those minimizers, followed by
querying them all at once.

#+name: query-throughput-1
#+caption: The typical code used to benchmark (minimal) perfect hash functions takes a list of keys, and measures the time it takes to =query= them one by one. This implicitly processes multiple queries in parallel. =black_box= is a Rust standard library function that ensures the query is not optimized away.
#+begin_src rust
fn benchmark(&self, keys: &Vec<Key>) -> Duration {
    let start = Instant::now()
    for key in keys {
        black_box(self.query(key));
    }
    start.elapsed()
}
#+end_src

#+name: query-throughput-2
#+caption: To allow explicit parallel processing of queries using prefetching, we change the benchmark to a single =query_all= function.
#+begin_src rust
fn benchmark(&self, keys: &Vec<Key>) -> Duration {
    let start = Instant::now()
    black_box(self.query_all(keys));
    start.elapsed()
}
#+end_src

*** Batch size
#+name: batching
#+caption: Batching
#+attr_html: :class inset
[[file:plots/query_batching.svg]]
- Compact is slow on small inputs because the loop is vectorized with SIMD,
  which ends up being slower.
- Query experiments always do 1G queries.
- n=20M n=1G
- linear/0.99/3.0 vs cubic/0.98/4.0
- no remap
- loop vs streaming vs batching
- 24: 1..128 batch size: 1,2,3,4,5,6,7,8,10,12,14,16,20,24,28,32,40,48,56,64,80,96,112,128
*** Throughput
#+name: throughput
#+caption: throughput
#+attr_html: :class inset
[[file:plots/query_throughput.svg]]
- 2: Linear/0.99/3.0 vs Cubic/0.98/4.0
- 2: loop vs streaming with known batch size
- 2: with/out remap (Vec & CachelineEF)
- 6: with 1..6 threads
  - random access memory throughput

** Comparison with competitors
- check out https://github.com/ByteHamster/MPHF-Experiments for evals

* Conclusion and future work

*Future work.*
- Faster than memory is possible, when most queries can be answered from a
  smaller cache.
- SIMD, although the widening multiplication complicates things

* Acknowledgements
- Giulio for ongoing discussions
- Sebastiano for trying the 10^12 construction.

* Appendix
** Rust and assembly code for streaming
[[streaming-code]] shows the Rust code for the streaming version of PtrHash, and
[[streaming-asm]] shows the corresponding assembly code with =perf record= results.

#+name: streaming-code
#+caption: Rust code for streaming indexing that prefetches $B$ iterations ahead.
#+begin_src rust
pub fn index_stream<'a, const B: usize, const MINIMAL: bool>(
    &'a self,
    keys: impl IntoIterator<Item = &'a Key> + 'a,
) -> impl Iterator<Item = usize> + 'a {
    // Append B values at the end of the iterator to make sure we wrap sufficiently.
    let mut hashes = keys.into_iter().map(|x| self.hash_key(x)).chain([0; B]);

    // Ring buffers to cache the hash and bucket of upcoming queries.
    let mut next_hashes: [Hx::H; B] = [Hx::H::default(); B];
    let mut next_buckets: [usize; B] = [0; B];

    // Initialize and prefetch first B values.
    for idx in 0..B {
        next_hashes[idx] = hashes.next().unwrap();
        next_buckets[idx] = self.bucket(next_hashes[idx]);
        crate::util::prefetch_index(self.pilots, next_buckets[idx]);
    }
    hashes.enumerate().map(move |(idx, next_hash)| {
        let idx = idx % B;
        let cur_hash = next_hashes[idx];
        let cur_bucket = next_buckets[idx];
        let pilot = self.pilots[cur_bucket];
        let mut slot = self.slot(cur_hash, pilot);
        if MINIMAL && slot >= self.n {
            slot = self.remap.index(slot - self.n) as usize;
        };

        // Prefetch B iterations ahead.
        next_hashes[idx] = next_hash;
        next_buckets[idx] = self.bucket(next_hashes[idx]);
        crate::util::prefetch_index(self.pilots, next_buckets[idx]);

        slot
    })
}
#+end_src

#+name: streaming-asm
#+caption: Assembly code of streaming indexing (without the final =remap=) that prefetches 32 iterations ahead, with =perf record= measurement of time time spent on each line. TODO: Update for latest version.
#+begin_src asm
  2.57 │ a0:   lea        (%r14,%rbp,1),%r12d
  0.95 │       mov        0x8(%rsp),%rdx
 16.93 │       mov        (%rdx,%r14,8),%rdx
  0.80 │       imul       %r11,%rdx
  2.30 │       and        $0x1f,%r12d
  0.90 │       mov        0x8(%rcx,%r12,8),%rsi
  1.36 │       mulx       %rbx,%r8,%r9
  2.24 │       mov        0x108(%rcx,%r12,8),%r10
  0.92 │       mov        %rdx,0x8(%rcx,%r12,8)
  0.48 │       mov        %r8,%rdx
  2.99 │       mulx       %r8,%rdx,%rdx
  1.03 │       mov        0x20(%rsp),%r8
  1.44 │       mulx       %r8,%rdx,%rdx
  2.15 │       imul       0x18(%rsp),%r9
  1.08 │       add        %rdx,%r9
  0.83 │       mov        %r9,0x108(%rcx,%r12,8)
 46.61 │       prefetcht0 (%r15,%r9,1)            ; Nearly half the time is spent here.
  1.39 │       movzbl     (%r15,%r10,1),%r8d
  0.54 │       imul       %r11,%r8
  0.31 │       xor        %rsi,%r8
  2.34 │       mov        %rsi,%rdx
  1.43 │       mulx       %rbx,%rdx,%rdx
  0.30 │       shlx       %r13,%rdx,%rdx
  2.43 │       add        %rdx,%rax
  0.87 │       mov        %r8,%rdx
  0.72 │       mulx       %r11,%rdx,%rdx
  2.37 │       and        %rdi,%rdx
  0.98 │       add        %rdx,%rax
  0.51 │       inc        %r14
       │       cmp        %r14,0x28(%rsp)
  0.23 │     ↑ jne        a0
#+end_src



* DONE Failed ideas
- always compute remap to avoid branch:
  - Instead, an additional layer of prefetching helps a bit, but too complicated
    and annoying.
- rattle kicking?
- 4bit pilots with buckets of half the size -> doesn't work.


#+print_bibliography:
